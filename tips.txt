============ compile & interactive mode ============================
$ rlwrap ocaml

ocamlopt hello.ml
ocamlopt -o hello hello.ml

実行はCと同じ

============ how to use type ====================
let average a b = (a +. b) /. 2.0;;

val average : float -> float -> float = <fun>

double average(double a, double b){
 return (a + b) /2 ;
}

OCaml は強い静的型付けされた言語です。(言い換えると、Perlのような動的型ではありません)
OCaml は型推論によって型を抽出するので、明示する必要はありません。OCamlのトップレベルで用いれば、OCamlは入力した関数の型を(OCaml がどう推論したのかを)教えてくれます。
OCaml には暗黙の型変換はありません。もし浮動小数点数を使うのであれば、2 は整数型なので 2.0 と書く必要があります。
OCaml には演算子の多重定義は禁止されているので、「整数の足し算(+)」 と「浮動小数点数の足し算(+. )」(付随するピリオドに注意)とで異なる演算子が用意されています。他の算術演算子も同様です。
OCaml は関数の最後の式を返値とするので、C のようにreturn を書く必要はありません。

*整数でなく実数の場合は演算子の後ろに"."をつける
Error:
  1 + 2.5;;
  1 +. 2.5;;

OK:
  (float_of_int 1) +. f

============ about variable =============================
名前 (識別子) は、先頭が英小文字またはアンダースコア ( _ ) で、
そのあとに英大文字、英小文字、数字、アポストロフィ ( ' )、アンダースコアが続きます。
英大文字で始まる名前は「コンストラクタ」、アポストロフィから始まる名前は「型変数」になるため、
変数名や関数名として用いることはできません
値のい書き換えは不可、再定義は可能
let a  = 10;;


============ about func =========================

再帰関数は let rec と明示する

let rec range a b =
  if a > b then []
  else a :: range (a+1) b;;

  val range : int -> int -> int list = <fun>

let と let rec の違いは関数名のスコープだけです。
この関数 range が単に let で定義された場合には、 range の呼び出しのところで、今定義しているところの range 関数 ではなく、
既に存在するはずの(既に定義された) range 関数を探します。
